/*
  Скетч к проекту "Универсальный контроллер"
  Страница проекта (схемы, описания): https://alexgyver.ru/gyvercontrol/
  Исходники на GitHub: https://github.com/AlexGyver/gyvercontrol
  Нравится, как написан и закомментирован код? Поддержи автора! https://alexgyver.ru/support_alex/
  Автор: AlexGyver Technologies, 2020
  http://AlexGyver.ru/
*/
// Версия 1.6
// Версия 1.6.2 - добавлена поддержка HTU21D (заменяет BME280)

// ================== СИСТЕМА ==================
#define START_MENU 0          // 1 - включить, 0 - отключить стартовое меню (старт с нажатой кнопкой). Там будет сервис и сброс настроек
#define USE_PLOTS 0           // 1 - включить, 0 - отключить вывод графиков
#define USE_DAWN 0            // включает/отключает поддержку режима РАССВЕТ на каналах 2, 3, серво1, серво2
#define USE_DRIVE 0           // включает/отключает поддержку линейного привода (в целях экономии памяти)

// =================== СЕРВО ===================
#define SERVO1_RELAY 1        // 1 - заменить серво 1 на реле (ЭКОНОМИТ ПАМЯТЬ). 0 - ничего не делать
#define SERVO2_RELAY 1        // 1 - заменить серво 2 на реле (ЭКОНОМИТ ПАМЯТЬ). 0 - ничего не делать
#define SMOOTH_SERVO 0        // 1 - использовать плавное управление серво, 0 - обычное (ЭКОНОМИТ ПАМЯТЬ)
#define SERVO_MIN_PULSE 500   // минимальный импульс серво (зависит от модели, 500-800)
#define SERVO_MAX_PULSE 2500  // максимальный импульс серво (зависит от модели, 2000-2500)

// ==================== ПИД ====================
#define USE_PID 0             // включает/отключает поддержку ПИД регулятора на каналах 2, 3, серво1, серво2 и привода
#define USE_PID_RELAY 0       // добавляет/отключает поддержку ПИД регулятора на каналах 0 и 1 (ШИМ-реле). Требует USE_PID для работы!
#define SCHEDULE_NUM 0        // меню расписания ПИД, задать количество расписаний (не больше 2!). 0 - выключить
#define PID_INT_MIN -3000     // ограничение интегральной составляющей, минимум
#define PID_INT_MAX 3000      // ограничение интегральной составляющей, максимум
#define PID_AUTOTUNE 0        // автокалибровщик ПИД
#define DEBUG_PID 0           // 0 - выкл режим отладки ПИД и отладки автокалибровки
// другое значение - канал отладки пид (1, 2, 3, 4 - обычные каналы, 5, 6 - серво, 7 - привод)
// вывод графиков на компьютер, открой "инструменты/плоттер по последовательному соединению"
// для отладки автотюна ставь любое отличное от 0 значение
// ПРИ РАБОТЕ ТЮНЕРА ИЛИ ОТЛАДКИ ОТКЛЮЧИТЕ ВСЁ ОТ 1 КАНАЛА! ОН БУДЕТ ВКЛЮЧЕН Т.К. НА НЁМ ПРИВЯЗАНА СВЯЗЬ
#define SHOW_INTEGRAL 1       // 1 - показывать график интегральной суммы, 0 - нет

// ================= УПРАВЛЕНИЕ =================
#define ENCODER_TYPE 1        // тип энкодера (0 или 1). Если энкодер работает некорректно (пропуск шагов/2 шага), смените тип
#define ENC_REVERSE 1         // 1 - инвертировать направление энкодера, 0 - нет
#define CONTROL_TYPE 1        // тип управления энкодером: 0 - удерживание и поворот для изменения значения, 1 - клик для входа в изменение, повторный клик для выхода (стрелочка меняется на галочку)
#define FAST_TURN 1           // 1 - вкл быстрый поворот
#define FAST_TURN_STEP 10     // изменение при быстром повороте

// ================== РАЗНОЕ ===================
#define DRIVER_LEVEL 1        // 1 или 0 - уровень сигнала на драйвер/реле для привода
#define DRIVE_TOUT 10         // секунд. Время, которое система будет ждать после ручного управления дверью, прежде чем применить режим
#define PWM_RELAY_HZ 1        // частота ШИМ для каналов ШИМ-реле, Гц (раз в секунду) можно десятичные дроби (0.1 - период будет 10 секунд)
#define SETT_TIMEOUT 100      // таймаут неактивности (секунд) после которого автоматически откроется DEBUG и сохранятся настройки
#define WIRE_OVERCLOCK 1      // 1 - увеличить частоту шины i2c до 400 кГц
#define LCD_ADDR 0x3f         // адрес дисплея - 0x27 или 0x3f . Смени если не работает!
#define BME_ADDR 0x76         // адрес BME280 - 0x76 или 0x77. Смени если не работает!

#define WDT_ENABLE 0          // 1 - включить, 0 - отключить watchdog (только для optiboot)
// Ссылка для оптибут:        https://github.com/Optiboot/optiboot/releases/download/v8.0/package_optiboot_optiboot-additional_index.json

// ============== НАЗВАНИЯ КАНАЛОВ =============
// (только английские буквы)
const char *channelNames[] = {
  "Channel 1",
  "Channel 2",
  "Channel 3",
  "Channel 4",
  "Channel 5",
  "Channel 6",
  "Channel 7",
  "Servo 1",
  "Servo 2",
  "Drive",
};

// ================== ДАТЧИКИ ==================
// ------------------ MH-Z19 -------------------
// входы SENS_1 или SENS_2 - датчик СО2
#define USE_CO2 0           // 1 - использовать MH-Z19, 0 - не использовать
#define CO2_PIN 1           // 1 или 2, соответственно подключать к SENS_1 или SENS_2 !!!
#define CO2_MAX 5000        // диапазон датчика (бывает 2000 и 5000)
#define CO2_CALIB 0         // 1 - оставить автокалибровку датчика (для жилых комнат), 0 - выключить (для теплиц)

// ------------------ bme280 ------------------
// шина i2c - цифровой датчик температуры и влажности
#define USE_BME 0           // 1 - использовать BME280, 0 - не использовать

// ------------------ HTU21D ------------------
// шина i2c - цифровой датчик температуры и влажности
#define USE_HTU21D 0        // 1 - использовать HTU21D, 0 - не использовать

// ------------------ ds18b20 -----------------
// вход SENS1 - цифровой датчик температуры
#define DALLAS_SENS1 0      // 1 - ко входу SENS1 подключен ds18b20, 0 - подключен обычный аналоговый датчик
#define DALLAS_AMOUNT 1     // количество далласов на ОДНОМ пине

// для нескольких далласов
#define DALLAS_MODE 0       // для нескольких датчиков, СЧИТАТЬ показания как:
// 0 - среднее из всех
// 1 - наибольшее из всех
// 2 - наименьшее из всех
#define DALLAS_DISP 0       // ОТОБРАЖЕНИЕ показаний:
// 0 - согласно режиму (показывает один результат)
// 1 - по очереди выводит показания в одно "окно" SENS1. Номер1, значение1, номер2, значение2...

// адреса датчиков. Количество должно соответствовать DALLAS_AMOUNT
#if (DALLAS_AMOUNT > 1)
const uint8_t dsAddress[][8] = {
  {0x28, 0xFF, 0x42, 0x5A, 0x51, 0x17, 0x4, 0xD2}, // адрес датчика 1
  {0x28, 0xFF, 0x53, 0xE5, 0x50, 0x17, 0x4, 0xC3}, // адрес датчика 2
  {0x28, 0xFF, 0x99, 0x80, 0x50, 0x17, 0x4, 0x4D}, // адрес датчика 3
  // по аналогии можно добавить ещё
};
#endif

// ---------------- DHT11/DHT22 ----------------
// вход SENS2 - цифровой датчик температуры и влажности, отображается вместо BME280
#define DHT_SENS2 0         // 1 - ко входу SENS2 подключен DHT11/DHT22, 0 - подключен обычный аналоговый датчик
#define DHT_TYPE DHT22      // тип DHT датчика: DHT11 или DHT22

// -------------- NTC термисторы ---------------
// входы SENS1 - SENS4
#define THERM1 0            // 1 - термистор на SENS1, 0 - нет
#define THERM2 0            // 1 - термистор на SENS2, 0 - нет
#define THERM3 0            // 1 - термистор на SENS3, 0 - нет
#define THERM4 0            // 1 - термистор на SENS4, 0 - нет

#define BETA_COEF1 3435     // температурный коэффициент термистора 1 (см. даташит)
#define BETA_COEF2 3435     // температурный коэффициент термистора 2 (см. даташит)
#define BETA_COEF3 3435     // температурный коэффициент термистора 3 (см. даташит)
#define BETA_COEF4 3435     // температурный коэффициент термистора 4 (см. даташит)

// ==================================================

#include "a1_data.h"
